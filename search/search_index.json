{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"GA-build/","title":"DITA CI/CD with GitHub Actions","text":"<p>GitHub Actions are a quick and easy way to automate build outputs form DITA content stored in a GitHub repository.</p> <p>The following code is a simple GitHub Actions workflow that builds HTML5 files from DITA content and deposits them in a branch called published. This build is kicked off on push or on pull requests to a the <code>main</code> branch. it's also possible to configure a cron job to run the build at a specific time, or to run the build manually.</p> <pre><code>name: site-build\n# Controls when the action will run. \non:\n# Triggers the workflow on push events but only for the main branch\npush:\nbranches: [ main ]\njobs:\nbuild-dita:\nname: Build DITA\nruns-on: ubuntu-latest\nsteps:\n- name: Git checkout\nuses: actions/checkout@v2\n- name: Build HTML5\nid: DITA-build\nuses: dita-ot/dita-build-action@master\nwith:\ninstall: |\ndita install fox.jason.extend.css\ndita install net.infotexture.dita-bootstrap\ndita install fox.jason.prismjs\nbuild:  |\ndita --project=myproject.xml          \n- name: Upload DITA\nid: upload\nuses: actions/upload-artifact@v2\nwith:\nname: dita-artifact\npath: \u2018out\u2019\n- name: Deploy\nid: deploy\nuses: JamesIves/github-pages-deploy-action@3.7.1\nwith:\nGITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\nBRANCH: published # The branch the action should deploy to.\nFOLDER: out # The folder the action should deploy.\nTARGET-FOLDER: docs          </code></pre> <p>The <code>jobs</code> section of the workflow file spins up an Ubuntu Linux instance and then runs a series of steps:</p> <ol> <li> <p>The first step, <code>Git checkout</code>, is a GitHub-provided action that checks out the current branch.</p> </li> <li> <p>The real work is done by the next step, <code>Build HTML5</code>. It uses the <code>dita-build-action</code> GitHub Action created by Jason Fox which downloads the latest version of the DITA Open Toolkit, installs 3 required plugins from the DITA-OT plugin registry, and runs the build instruction using the <code>myproject.xml</code> project file stored in the branch. The <code>myproject.xml</code> project file contains all the information on the source ditamap, output transtype, output folder, filter files, and any build parameters. For more information on configuring project files, see .</p> </li> <li> <p>The third step, <code>Upload DITA</code>, uploads the files outputted by the build to a folder called <code>out</code>.</p> </li> <li> <p>The last step, Deploy uses a GitHub action written by James Ives originally meant to deploy content to a GitHub Pages branch but used here to move the content of the <code>out</code> folder on the <code>main</code> branch to the <code>docs</code> folder in the <code>published</code> branch. From there web hooks could be employed to upload the content to a service like Netlify.</p> </li> </ol>"},{"location":"GA-build/#manual-builds","title":"Manual builds","text":"<p>The example above runs when you push content to the <code>main</code> branch. When you are testing builds, it's easier to run builds manually. Adding the <code>workflow_dispatch</code> event trigger to your workflow file allows you to build manually by clicking Run workflow on the Actions tab in the GitHub UI.</p> <pre><code>name: site-build\non:\n# Allows you to run this workflow manually from the Actions tab\nworkflow_dispatch:\n...\n</code></pre>"},{"location":"GA-build/#timed-builds-with-cron","title":"Timed builds with cron","text":"<p>In a mature CI/CD docs environment, documentation can be built and deployed on a regular, perhaps daily, basis. Workflows can integrate cron jobs that kick off the builds on specified days and times. The example below runs the build every weekday night at 2am:</p> <pre><code>name: site-build\non:\nschedule:\n# Runs \"at 02:00 every Mon-Fri\"\n- cron: '* 2 * * 1-5'\n...\n</code></pre> <p>Tip</p> <p>For help with cron notation, https://crontab.guru/ is useful resource.</p>"},{"location":"HDITA-tags/","title":"HTML5 tags in MDITA topics","text":"<p>HDITA is the HTML5 flavor of LwDITA. You can write entire topics in HDITA of course but those tags that you use to augment functionality in MDITA topics are of interest here. You can use the following HDITA/HTML5 tags in MDITA:</p> <ul> <li> <p><code>&lt;em&gt;</code>: to italicize text.</p> </li> <li> <p><code>&lt;strong&gt;</code>: to embolden text.</p> </li> <li> <p><code>&lt;u&gt;</code>: to underline text (avoid using underlining).</p> </li> <li> <p><code>&lt;dl&gt;</code>: a definition list</p> </li> <li> <p><code>&lt;dt&gt;</code> inside <code>&lt;dl&gt;</code>: a definition term.</p> </li> <li> <p><code>&lt;dd&gt;</code> inside <code>&lt;dt&gt;</code>: a definition description.</p> </li> <li> <p><code>&lt;figure&gt;</code>: a container for an image.</p> </li> <li> <p><code>&lt;img&gt;</code>: an image.</p> </li> <li> <p><code>&lt;ol&gt;</code>: to introduce an ordered list.</p> </li> <li> <p><code>&lt;ul&gt;</code>: to introduce an unordered list.</p> </li> <li> <p><code>&lt;li&gt;</code> inside <code>&lt;ul&gt;</code> or <code>&lt;ol&gt;</code>: a list item.</p> </li> <li> <p><code>&lt;p&gt;</code>: a paragraph. Especially important when using context references.</p> </li> <li> <p><code>&lt;span&gt;</code>: a span of text. Used mostly for key references within notes and context referenced text.</p> </li> <li> <p><code>&lt;codeblock&gt;</code>: to indicate code or teletype text.</p> </li> <li> <p><code>&lt;section&gt;</code>: To define a new section in HTML content.</p> </li> <li> <p><code>&lt;a href&gt;</code>: an anchor tag for links.</p> </li> <li> <p><code>&lt;sub&gt;</code>: for subscript content.</p> </li> <li> <p><code>&lt;sup&gt;</code>: for superscript content.</p> </li> <li> <p><code>&lt;audio&gt;</code>: to embed audio content.</p> </li> <li> <p><code>&lt;video&gt;</code>: to embed video content.</p> </li> <li> <p><code>&lt;source&gt;</code>: inside <code>&lt;audio&gt;</code> or <code>&lt;video&gt;</code>: to indicate the path to a video or audio source file.</p> </li> <li> <p><code>&lt;table&gt;</code>: a table</p> </li> <li> <p><code>&lt;tr&gt;</code>: inside <code>&lt;table&gt;</code>: a table row.</p> </li> <li> <p><code>&lt;th&gt;</code>: inside <code>&lt;tr&gt;</code>: a table header row.</p> </li> <li> <p><code>&lt;td&gt;</code>: inside <code>&lt;tr&gt;</code>: a table cell.</p> </li> </ul> <p>Each tag also has one or more attributes but see the latest LwDITA specification doc for those details.</p> <p>Many of the tags do have Markdown counterparts so why would you use them? Well, the short answer is for encapsulating text you want to reuse or filter. You can find out about that in more detail further on in Using content references with MDITA and Using filters with MDITA.</p>"},{"location":"HDITA-tags/#when-to-use-html5-tags-in-mdita-files","title":"When to use HTML5 tags in MDITA files","text":"<p>There are 4 main occasion when you need to include HTML code in your MDITA Markdown content:</p> <ol> <li> <p>For notes/alerts/admonitions (for more information, see MDITA topic syntax).</p> </li> <li> <p>For context reference (conref) content pulled in from another file (for more information, see Using content references with MDITA).</p> </li> <li> <p>For text to apply a filter to (for more information, see Using filters with MDITA).</p> </li> <li> <p>For embedding video (for more information, see MDITA topic syntax).</p> </li> </ol>"},{"location":"MDITA-conrefs/","title":"Using content references with MDITA","text":"<p>For content that appears in several locations in document, DITA writers use the content referencing (conref) mechanism. Again, this is functionality that was impossible with Markdown on its own. Some static site generators, such as Jekyll, permitted the use of includes but each include had to be a separate HTML file. You can use a conref file (also sometimes called a warehouse file) to put all referenced content in one place.</p> <p>The bst practice for using conrefs involves placing the content you want to reuse in a separate warehouse file which doesn't itself appear in the final output.</p> <p>You can use a MDITA Markdown topic as a warehouse file but the content you want to reference must be in HDITA tags. The Markdown warehouse topic must include a YAML header with an idea (as in the example below).</p> <p>A sample MDITA conref warehouse topic:</p> <pre><code>---\nid: conref-content\n---\n\n# Conref content\n\n&lt;p id=\"install-step1\"&gt;First, download the appropriate installer for your operating system from the Grunt Master website [Downloads](https://gruntmaster.com/downloads) page.&lt;/p&gt;\n&lt;p id=\"disclaimer\"&gt;Grunt Master Industries accepts no liability for any injury, insanity, infertility, or death caused by even casual use of the Grunt Master 6000.&lt;/p&gt;\n...\n</code></pre> <p>To reference the shared content within an MDITA Markdown file, you must use an HDITA tag must along with the data-conref attribute. The value for the data-conref attribute uses the following format <code>&lt;TOPIC FILE NAME&gt;#&lt;TOPIC ID&gt;/&lt;TAG ID&gt;</code>. For example:</p> <pre><code>## Installing the Grunt Master 6000 companion app\n\nFollow the instructions below to install the Grunt Master 6000 companion app:\n\n1. &lt;p data-conref=\"conref.md#conref-content/install-step1\"&gt;&lt;/p&gt; &lt;--! Reviewers go to conref.md and look at the paragraph with the install-step1 ID if you want to review this step. --&gt;\n1. Double-click on the installer, and follower the installation wizard instructions.\n1. When installation is complete, restart your device. &lt;p data-conref=\"conref.md#conref-content/disclaimer\"&gt;&lt;/p&gt;\n</code></pre> <p>The build process replaces HDITA tag with the referenced text.</p> <p>As in the above example, it's a good idea to add a comment that points reviewers towards the conref source in case they might want to review that content too.</p>"},{"location":"MDITA-conrefs/#keys-in-conref-text","title":"Keys in conref text","text":"<p>Because conref content is HTML not Markdown you can't use references to any keys you have defined in the ditamap. For example if you used [company_name] in a the conref snippet, the build process renders literally as \"[company_name]\" and not Grunt Industries\"*. Therefore, as a general rule, try to avoid using content that you have also made into text variables in conref content.</p>"},{"location":"MDITA-filters/","title":"Using filters with MDITA","text":"<p>You use MDITA filters to apply build conditions. In other words, to exclude certain text elements that aren't relevant, for example, to certain readers, or for certain software versions, or releases. By applying different filters to an MDITA document you can produce different versions of the document to suit different purposes.</p> <p>To incorporate text that you want to filter out at build time, MDITA topics must include HDITA tags that use the props attribute. Note in the example below that the entire unordered list must be in HTML markup not simply the list items you intend to filter.</p> <pre><code>## Supported Operating Systems\n\nThe following operating systems are supported by the [product_name] companion app:\n\n&lt;ul&gt;\n&lt;li props=\"mac\"&gt;Mac&lt;/li&gt;\n&lt;li&gt;Windows&lt;/li&gt;\n&lt;li props=\"linux\"&gt;Linux&lt;/li&gt;\n&lt;li&gt;BSD&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre> <p>You use a special ditaval filter file to filter content. To filter out the first list item, the ditaval file used by the build instruction is:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;val&gt;\n&lt;prop action=\"exclude\" att=\"props\" val=\"mac\"/&gt;\n&lt;/val&gt;\n</code></pre> <p>The props attribute can also added at the map level to filter out whole files from a build:</p> <pre><code>&lt;topicref href=\"somefile.md\" format=\"markdown\" props=\"mac\"/&gt;\n</code></pre> <p>Warning</p> <p>If the props attribute is added to a <code>&lt;topicref&gt;</code> element that has child topics, the children will also be filtered out.</p>"},{"location":"MDITA-keys/","title":"Using keys","text":"<p>The use of keys in root maps isn't mandatory but it's best practice. Keys can play an important role in:</p> <ul> <li> <p>Managing internal links so that path and names of topics in a map can be changed without breaking cross references.</p> </li> <li> <p>Managing external links so that links to external resources that appear more than once in a document can be more updated in one go if the URL changes.</p> </li> <li> <p>Creating text variables for things like company and product names so that these can be updated everywhere in the document if they change, without resorting to risky global find and replace commands, or painful manual updating.</p> </li> </ul>"},{"location":"MDITA-keys/#using-keys-for-internal-links","title":"Using keys for internal links","text":"<p>By adding a keys attribute value to a topic's <code>&lt;topicref&gt;</code> in your map, you can reference the key value within square brackets in any topic and the output generates a link to the topic with the topic title. For example, you link to this topic in the following way:</p> <pre><code>For more information, see [using-maps].\n</code></pre> <p>The key using-maps is the value of the keys attribute for the topic reference for this topic in the current document ditamap.</p> <p>By using this method, you can change the name or the path to the Markdown file referenced in the href attribute in your <code>&lt;topicref&gt;</code> without breaking any references to the file in the document itself.</p>"},{"location":"MDITA-keys/#using-keys-for-external-links","title":"Using keys for external links","text":"<p>As you have no control over the URL of an external link, and you might use the same external link many times in a document, it's best practice to keep your external links in their own ditamap and reference them using keys (just as you would for internal links). Here is an example of an external links ditamap:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE map PUBLIC \"-//OASIS//DTD DITA Map//EN\" \"map.dtd\"&gt;\n&lt;map id=\"extlinks\"&gt;    &lt;title&gt;External links&lt;/title&gt;\n&lt;topicref format=\"html\" href=\"https://www.commonmark.org\" keys=\"commonmark\" scope=\"external\" &gt;\n&lt;topicmeta&gt;\n&lt;navtitle&gt;CommonMark specification&lt;/navtitle&gt;\n&lt;/topicmeta&gt;\n&lt;/topicref&gt;\n&lt;topicref format=\"html\" href=\"https://books.google.co.uk/books/about/Docs_Like_Code.html)\" keys=\"docs-like-code\" scope=\"external\" &gt; &lt;topicmeta&gt;\n&lt;navtitle&gt;Docs like code&lt;/navtitle&gt;\n&lt;/topicmeta&gt;\n&lt;/topicref&gt;\n&lt;topicref format=\"html\" href=\"https://www.dita-ot.org/dev/topics/markdown-dita-syntax-reference.html\" keys=\"MDITA-syntax-ref\" scope=\"external\"&gt;\n&lt;topicmeta&gt;\n&lt;navtitle&gt;MDITA syntax reference&lt;/navtitle&gt;\n&lt;/topicmeta&gt;\n&lt;/topicref&gt;    &lt;/map&gt;\n</code></pre> <p>A few things of note:</p> <ul> <li> <p>The format attribute uses html as a value because the reference is to a web page.</p> </li> <li> <p>Unlike internal links, you have to explicitly define the link text for external links via the <code>&lt;topicmeta&gt;</code> and <code>&lt;navtitle&gt;</code> tags. If you omit the <code>&lt;topicmeta&gt;</code> and <code>&lt;navtitle&gt;</code> tags, the link text is replaced by the URL.</p> </li> <li> <p>The <code>&lt;topicmeta&gt;</code> tag is a container for metadata (in this case title of the web page that appears in the link).</p> </li> <li> <p>The <code>&lt;navtitle&gt;</code> tag contains the link text that the reader sees whenyou build the document.</p> </li> </ul> <p>To reference the last item in the map, use the following:</p> <pre><code>For more information see [MDITA-syntax-ref].\n</code></pre> <p>The build process replaces the key value by a link entitled \"MDITA syntax reference\".</p> <p>Although you can use the standard Markdown linking format to place external links in the body of a topic (and initially that might seem easier), the use of external links maps makes updating external URLs much easier.</p> <p>An external links map is added as a submap to the root map using a &lt;mapref&gt; tag with the processing-role set to resource-only (see Organizing topics with maps for an example).</p>"},{"location":"MDITA-keys/#using-mdita-keys-for-text-variables","title":"Using MDITA keys for text variables","text":"<p>MDITA keys also allow you to create text variables. This is functionality that is simply impossible with common-or-garden Markdown.</p> <p>Keys in DITA provide an means of indirect referencing. Keys are defined in a ditamap. They can be added to a root map or - if there are many - contained in a map of their own which is referenced in the root map.</p> <p>The recommended format for creating a key definition in an XDITA map is:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE map PUBLIC \"-//OASIS//DTD DITA Map//EN\" \"map.dtd\"&gt;\n&lt;map id=\"Keydefs\"&gt; &lt;title&gt;Key Definitions&lt;/title&gt;\n&lt;keydef keys=\"company_name\"&gt;\n&lt;topicmeta&gt;\n&lt;keywords&gt;\n&lt;keyword&gt;Grunt Industries&lt;/keyword&gt;\n&lt;/keywords&gt;\n&lt;/topicmeta&gt;\n&lt;/keydef&gt;\n&lt;keydef keys=\"product_name\"&gt;\n&lt;topicmeta&gt;\n&lt;keywords&gt;\n&lt;keyword&gt;Grunt Master 6000&lt;/keyword&gt;\n&lt;/keywords&gt;\n&lt;/topicmeta&gt;\n&lt;/keydef&gt;\n&lt;/map&gt;    </code></pre> <p>As you can see, this ditamap doesn't reference any topics. It just defines keys, and you add it to the root map using a <code>&lt;mapref&gt;</code> tag with the processing-role set to resource-only (see Organizing topics with maps for an example). Here are the tags used in the above example in more detail:</p> <ul> <li> <p>keydef - You use this tag to define the key itself by setting a value in the keys attribute.</p> </li> <li> <p>topicmeta - This tag is a container for metadata (in this case the variable string used by the key). The <code>&lt;topicmeta&gt;</code> tag can be a container for several tags but it only contains those you see in the above example.</p> </li> <li> <p>keywords - The <code>&lt;keywords&gt;</code> tag holds the keyword that it's the value of the key.</p> </li> <li> <p>keyword - The <code>&lt;keyword&gt;</code> tag contains the text string itself.</p> </li> </ul> <p>When you are defining keys always use the format of tags shown above.</p> <p>Within an MDITA topic, you reference the key by putting it within square brackets, for example:</p> <pre><code>The [product_name] represents a leap forward in home exercise technology by [company_name]! </code></pre> <p>The build process replaces [product_name] by Grunt Master 6000, and [company_name] by Grunt Industries.</p>"},{"location":"MDITA-keys/#referencing-keys-in-html5-content","title":"Referencing keys in HTML5 content","text":"<p>Because some content in MDITA files, such as notes and context references (for more information on context references see Using content references with MDITA), is in HTML and not Markdown. The usual methods for referencing keys don't work.</p> <p>So to add a text variable in HTML text in an MDITA, use <code>&lt;span data-keyref=\"company_name\"&gt;&lt;/span&gt;</code> in stead of [company_name]. For example:</p> <pre><code>&lt;p id=\"disclaimer\"&gt;&lt;note&gt;&lt;span data-keyref=\"company_name\"&gt;&lt;/span&gt; accepts no liability for any mental illness, blindness, infertility, or death caused by even casual use of the &lt;span data-keyref=\"product_name\"/&gt;&lt;/span&gt;.&lt;/note&gt;&lt;/p&gt;\n</code></pre> <p>The next example includes a key reference for an external link defined in the external links ditamap:</p> <pre><code>&lt;p id=\"install-step1\"&gt;First, download the appropriate installer for your operating system from the &lt;span data-keyref=\"company_name\"&gt;&lt;/span&gt; website &lt;span data-keyref=\"grunt-downloads\"&gt;&lt;/span&gt; page. &lt;/p&gt;\n</code></pre> <p>The example below is for an internal link, referencing a key from the root map:</p> <pre><code>&lt;p&gt;&lt;note type=\"tip\"&gt;For more information on using filters in MDITA documents, see &lt;span data-keyref=\"MDITA-filters\"&gt;&lt;/span&gt;.&lt;/note&gt;&lt;/p&gt;\n</code></pre>"},{"location":"add-search-bootstrap-plugin/","title":"Adding search","text":"<p>The DITA-Bootstrap plugin (or to give it its proper name, the net.infotexture.dita-bootstrap plugin) is a customized version of the DITA Open Toolkit (DITA-OT) HTML5 plugin that uses the Bootstrap 5 CSS framework. The DITA-OT HTML5 plugin produces unstyled HTML5 output. The DITA Bootstrap plugin look and feel replicates the Bootstrap 5 documentation template.</p> <p>You can install the plugin into the DITA-OT by using the <code>dita install</code> command:</p> <pre><code>dita install net.infotexture.dita-bootstrap\n</code></pre> <p>It's not necessary to go into the many styling and configuration possibilities offered by the DITA Bootstrap plugin here. See the DITA Bootstrap GitHub pages site for information on the various plugin configuration options.</p> <p>Many Bootstrap widgets and other features have been integrated into the plugin, but it lacks a search bar and any integrated search functionality. It's possible to integrate 3rd party server-based search functionality (such as Algolia DocSearch or Google Custom Search), as well as client-based JavaScript search libraries.</p>"},{"location":"automating-builds/","title":"Automating DITA builds","text":"<p>Back in the day I used to automate my DITA-OT builds by writing shell scripts that chained DITA build commands along with their various build parameters one after the other.</p> <p>Then <code>.properties</code> files came along and it became a lot easier to do builds because you could put most of a document's build parameters in a single file and call it from the DITA build command, as in the example below:</p> <pre><code>dita -i my_map.ditamap -o out/pdfs --format=pdf2 --filter=my_filter.ditaval --propertyfile=my_build.properties\n</code></pre> <p>This made for more concise shell scripts because the build parameters for most documents were the same and you could call the same <code>.properties</code> file for most of your build commands. However, if you required different parameters for a document, you needed a different <code>.properties</code> file. Each <code>.properties</code> file could only list the parameters for one output format, and you still needed to use a different DITA build command in your script for every document you wanted to build.</p>"},{"location":"automating-builds/#project-files","title":"Project files","text":"<p>Finally with DITA-OT release 3.4 came project files. Project files allow you to put all the build parameters (including input files, output folders, output formats, and filters) all in the same file for multiple documents. You can even define multiple outputs with different parameters for the same document.</p> <p>Your DITA build command now looks something like this:</p> <pre><code>dita --project=myproject.xml -v\n</code></pre> <p>Note: The <code>-v</code> switch simply tells the DITA Open Toolkit to use verbose mode and run the log file in the command prompt window.</p> <p>The above example uses a project file in XML format. You can also write them in YAML and JSON.</p> <ul> <li> <p>DITA-OT project file structure </p> </li> <li> <p>Building multiple documents </p> </li> <li> <p>Other things you can do with project files </p> </li> </ul>"},{"location":"build-multiple-docs/","title":"Building multiple documents","text":"<p>The example shown in DITA-OT project file structure was for one document deliverable in one output format. But with project files you can include many different deliverables and even several different deliverables for the same ditamap. See the following sample project file, <code>gm_deliverables.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"https://www.dita-ot.org/project\"&gt;\n\n&lt;--! Grunt Master 6000 Guide deliverables --&gt;\n\n&lt;deliverable name=\"Grunt Master 6000 Guide\" id=\"ug_gruntmaster6000_html5\"&gt; \n    &lt;context name=\"Grunt Master 6000 Guide\" id=\"ug_gruntmaster6000\"&gt;\n        &lt;input href=\"ug_gruntmaster6000.ditamap\"/&gt;\n        &lt;profile&gt;\n            &lt;ditaval href=\"GM6000.ditaval\"/&gt;\n        &lt;/profile&gt;\n    &lt;/context&gt;\n    &lt;output href=\"./html5-output\"/&gt;\n    &lt;publication transtype=\"html5\"&gt;\n        &lt;param name=\"args.css\" href=\"../css/custom.css\"/&gt;\n        &lt;param name=\"args.copycss\" value=\"yes\"/&gt;\n    &lt;/publication&gt;\n  &lt;/deliverable&gt;\n\n&lt;--! Grunt Master 3000 Guide deliverables --&gt;\n\n  &lt;context name=\"Grunt Master 3000 Guide\" id=\"ug_gruntmaster3000\"&gt;\n    &lt;input href=\"ug_gruntmaster3000.ditamap\"/&gt;\n    &lt;profile&gt;\n      &lt;ditaval href=\"GM3000.ditaval\"/&gt;\n    &lt;/profile&gt;\n  &lt;/context&gt;\n\n  &lt;deliverable name=\"Grunt Master 3000 Guide\" id=\"ug_gruntmaster3000_html5\"&gt;\n    &lt;context idref=\"ug_gruntmaster3000\"/&gt;\n    &lt;output href=\"./html5-output\"/&gt;\n    &lt;publication transtype=\"html5\"&gt;\n      &lt;param name=\"args.css\" href=\"../css/custom.css\"/&gt;\n      &lt;param name=\"args.copycss\" value=\"yes\"/&gt;\n    &lt;/publication&gt;\n  &lt;/deliverable&gt;\n\n&lt;deliverable name=\"Grunt Master 3000 Guide\" id=\"ug_gruntmaster3000_pdf\"&gt;\n    &lt;context idref=\"ug_gruntmaster3000\"/&gt;\n    &lt;output href=\"./pdf-output\"/&gt;\n    &lt;publication transtype=\"pdf2\"&gt;\n      &lt;param name=\"args.chapter.layout\" href=\"BASIC\"/&gt;\n      &lt;param name=\"outputFile.base\" value=\"Grunt Master 3000 Guide\"/&gt;\n    &lt;/publication&gt;\n  &lt;/deliverable&gt;\n\n&lt;/project&gt;\n</code></pre> <p>The above example builds 3 deliverables from 2 source ditamaps. All 3 deliverables can be built with just one command:</p> <pre><code>dita --project=gm_deliverables.xml\n</code></pre> <p>The first part builds HTML5 output for the Grunt Master 6000 Guide.</p> <p>The second part builds HTML5 and PDF outputs for the Grunt Master 3000 Guide using two different filter files.</p> <p>Notice in this section of the project file that the <code>context</code> is independent of the <code>deliverable</code> sections, and that there are two <code>deliverable</code> sections that both have their own &lt;context&gt; elements which reference the same <code>context</code> ID via the <code>idref</code> attribute.</p> <p>Parent topic:Automating DITA builds</p>"},{"location":"cc_config/","title":"Creating a <code>cc_config.xml</code> file","text":"<p>The Oxygen <code>cc_config.xml</code> file allows you to define which DITA elements and attributes you want to make available in the Elements and Attributes windows in the Oxygen UI. By configuring element proposals in the <code>cc_config.xml</code> file, you can control which elements and attributes your users can add to topics and maps.</p> <p>Note</p> <p>You aren't writing a new DTD here, so a writer could technically manually type in any legal DITA element or attribute and the topic would still validate.</p> <p>To create a new <code>cc_config.xml</code> file, you could copy and edit the default file that lives in the <code>[Oxygen install folder]/frameworks/dita/resources</code> folder. Alternatively you can create one from scratch using a conveniently provided template that you can open from File&gt;New&gt;Framework templates&gt;Oxygen extensions&gt;Content Completion Configuration.</p> <p>The template has some sample code (which you can adopt or delete). The Oxygen online help provides comprehensive information on how work with the <code>cc_config.xml</code> file.</p> <p>For more information, see OxygenXML Help: Customize Content Completion.</p>"},{"location":"cc_config/#a-sample-cc_configxml-file","title":"A sample cc_config.xml file","text":"<p>See below a sample <code>cc_config.xml</code> file based largely on the Lightweight DITA 1.0 XDITA proposal for a reduced list of DITA elements. Of course, your <code>cc_config.xml</code> file could contain any elements and attributes you deem necessary.</p> <p>In addition to restricting the available elements and attributes for users, this <code>cc_config.xml</code> file also defines child elements or mandatory attributes and attribute values that you can include (or omit) for some elements. To give one example, if you add a <code>&lt;section&gt;</code> element, Oxygen also adds a <code>&lt;title&gt;</code> and <code>&lt;p&gt;</code> child elements.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!-- \n    Allows contributing to the values presented on content completion for element and attribute values.\n    You can append to the values obtained from the schema or replace them all together.\n    These values can be given as literal values or they can be obtained by executing an XSLT script.\n    IMPORTANT: This file must be saved as cc_config.xml in a folder that is present in the Classpath\n    of the Document Type (or framework).\n--&gt;\n&lt;?xml-model href=\"http://www.oxygenxml.com/ns/ccfilter/config/ccConfigSchemaFilter.sch\" type=\"application/xml\" schematypens=\"http://purl.oclc.org/dsdl/schematron\"?&gt;\n&lt;config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\nxsi:schemaLocation=\"http://www.oxygenxml.com/ns/ccfilter/config http://www.oxygenxml.com/ns/ccfilter/config/ccConfigSchemaFilter.xsd\"\nxmlns=\"http://www.oxygenxml.com/ns/ccfilter/config\"&gt;\n&lt;elementProposals\npossibleElements=\"\n        topic title shortdesc prolog body section p \n        ph ul ol li dl \n        dlentry dt dd pre \n        simpletable sthead strow stentry \n        fig image object desc alt note tt xref\n        map topicref topicmeta navtitle data mapref keydef keywords keyword         \n        \"\npossibleAttributes=\"\n        DITAArchVersion \n        domains class outputclass \n        id href conref keyref keys \n        processing-role scope format type \n        props others dir xml:lang translate\"/&gt;\n&lt;elementProposals path=\"ol/li\" insertElements=\"p\"/&gt;\n&lt;elementProposals path=\"ul/li\" insertElements=\"p\"/&gt;\n&lt;elementProposals path=\"image\" rejectAttributes=\"alt\"/&gt;\n&lt;elementProposals path=\"image\" insertElements=\"alt\"/&gt;\n&lt;elementProposals path=\"fig\" insertElements=\"title image\"/&gt;\n&lt;elementProposals path=\"section\" insertElements=\"title p\"/&gt;\n&lt;elementProposals path=\"table\" insertElements=\"title\"/&gt;\n&lt;elementProposals path=\"topicref\" rejectAttributes=\"navtitle\"/&gt;\n&lt;elementProposals path=\"pre\"&gt;\n&lt;insertAttribute name=\"translate\" value=\"no\"/&gt;\n&lt;/elementProposals&gt;\n&lt;elementProposals path=\"tt\"&gt;\n&lt;insertAttribute name=\"translate\" value=\"no\"/&gt;\n&lt;/elementProposals&gt;\n&lt;match attributeName=\"translate\"&gt;\n&lt;items action=\"addIfEmpty\"&gt;\n&lt;item value=\"yes\"/&gt;\n&lt;item value=\"no\"/&gt;\n&lt;/items&gt;\n&lt;/match&gt;\n&lt;match elementName=\"note\" attributeName=\"type\" editable=\"onlyAllowedItems\"&gt;\n&lt;items action=\"replace\"&gt;\n&lt;item value=\"note\"/&gt;\n&lt;item value=\"caution\"/&gt;\n&lt;item value=\"tip\"/&gt;\n&lt;item value=\"important\"/&gt;\n&lt;item value=\"remember\"/&gt;\n&lt;item value=\"restriction\"/&gt;\n&lt;item value=\"other\"/&gt;\n&lt;/items&gt;\n&lt;/match\n\n&lt;/config&gt;\n</code></pre>"},{"location":"cfg-dita-ot-action/","title":"Configuring the dita-ot-action","text":"<p>There are several ways to configure the dita-ot-action GitHub Action. The DITA-OT website has detailed instructions and the <code>docsrc/samples/github-actions</code> folder (within the DITA-OT install folder) has several sample workflow files, and on the DITA-OT docs GitHub repository.</p> <p>The use of Project files is the simplest course of action when building using the dita-ot-action because a lot of the configuration is in the project file itself and doesn't have to be added to the workflow YAML file.</p>"},{"location":"cfg-dita-ot-action/#installing-community-plugins","title":"Installing community plugins","text":"<p>There are a limited number of basic plugins included with the DITA-OT. However, other community developed plugins are available in the DITA-OT plugin registry. These can be installed using the <code>dita install</code> command as in the following excerpt:</p> <pre><code>...\njobs:\nbuild-dita:\nname: Build DITA\nruns-on: ubuntu-latest\nsteps:\n- name: Git checkout\nuses: actions/checkout@v2\n- name: Build HTML5\nid: DITA-build\nuses: dita-ot/dita-build-action@master\nwith:\n**install: \\|\ndita install fox.jason.extend.css\ndita install net.infotexture.dita-bootstrap\ndita install fox.jason.prismjs**\nbuild:  |\ndita --project=myproject.xml  \n...\n</code></pre>"},{"location":"cfg-dita-ot-action/#installing-custom-plugins","title":"Installing custom plugins","text":"<p>Most companies that use DITA develop custom DITA-OT plugins at some point. There are two ways to add a custom plugin: via a custom registry or, the old-fashioned way, via a plugin ZIP archive. The former method involves forking the DITA-OT plugin registry, uploading your plugins to it, and creating a JSON registry file for each plugin. This is only worthwhile in my opinion if you have a lot of custom plugins, and a lot of folks installing and uninstalling them on a regular basis. As far as GitHub actions are concerned, simply installing a plugin as a ZIP archive from another repository is a lot easier.</p> <p>To do this, upload you custom plugin files unzipped to a dedicated branch in a GitHub repository. GitHub zips the content in the background and you can install the ZIP archive by passing it as a URL to the <code>dita install</code> command.</p> <p>The following example installs a plugin from a user (myCompany) repository (DITA-plugins) custom_pdf branch.</p> <pre><code>...\njobs:\nbuild-dita:\nname: Build DITA\nruns-on: ubuntu-latest\nsteps:\n- name: Git checkout\nuses: actions/checkout@v2\n- name: Build Custom PDF\nid: DITA-build\nuses: dita-ot/dita-build-action@master\nwith:\n**install: \\|\ndita install https://github.com/myCompany/DITA-plugins/archive/custom\\_pdf.zip**\nbuild:  |\ndita --project=myproject.xml  \n...\n</code></pre> <p>Parent topic:DITA CI/CD with GitHub Actions</p>"},{"location":"conclusion/","title":"Are theme files worth using?","text":"<p>Despite their limitation, theme files are definitely worth using. Yes, you will still need some knowledge of XSL-FO properties but anyone with some knowledge of CSS would be able to pick that up pretty quickly. True, your docs will not look quite as pretty as those made with a custom PDF plugin, but you can still make pretty good looking and totally functional documents using theme files.</p> <p>The big benefit here is ease of use and maintenance. Currently if a request to change some styling on our PDF output comes in while I'm away on holiday, it has to wait until I come back because no-one else in the team dares touch the custom plugins with any confidence. But a little training is all it takes for anyone on the team to take a stab at replacing a cover image or changing the corporate colors in a theme file.</p> <p>And when it comes to developing PDFs from DITA content, using theme files comes a whole lot cheaper than paying a consultant to write a plugin.</p> <p>I work for a company that has a lot of very long, complex documents that are outputted to PDF. I am actively looking at ways we can simplify the styling and structure of our documents so that they can be build using a theme file and the standard PDF2 plugin rather than the current custom PDF2 customization layer plugin I wrote. This will enable the team to continue to style and maintain the PDF output when I am not around. However, if you have a complicated PDF plugin doing fancy things with map variables, cover pages, and header/footer content, theme files will simply not be able to replicate everything.</p> <p>Parent topic:PDF2 theme files</p>"},{"location":"create_mapframework/","title":"Creating the <code>simple_ditamap</code> framework","text":"<p>Having created the topic framework <code>simple_dita</code>, the next task is to create a map framework. For simplicity's sake, let's call it <code>simple_ditamap</code>.</p> <ol> <li> <p>If the Preferences dialog is not already open, go to Options&gt;Preferences&gt;Document Type Association.</p> </li> <li> <p>Click DITA Map and then Extend.</p> </li> <li> <p>In the Document type dialog that opens:</p> <ol> <li> <p>Give the new framework a Name. I used SIMPLE DITAMAP.</p> </li> <li> <p>Set Priority to Highest.</p> </li> <li> <p>Set Storage to External, and click the folder icon to navigate to the <code>simple_ditamap</code> folder within your <code>customer_frameworks</code> folder.</p> </li> <li> <p>On the Classpath tab, select the <code>${baseFramework}/resources</code> row and click the wrench icon.</p> <p>Change the content in the Directory field to <code>${frameworkDir}/resources/</code> and click OK. In this case, the <code>${frameworkDir}</code> variable contains the path to the <code>custom_frameworks/simple_ditamap</code> folder.</p> </li> <li> <p>On the Templates tab, select all the rows and click the X icon to delete them all. Click the + icon, and enter <code>${frameworkDir}/templates/</code> in the Directory field and click OK.</p> </li> <li> <p>On the Author tab, edit the Menu, Contextual Menu, Toolbar, and Content Completion sub-tabs, to add or remove any icons not relevant to your framework.</p> </li> <li> <p>Click OK, and then OK again close the Preferences dialog.</p> </li> </ol> </li> </ol> <p>Once completed, your Elements and Attributes windows in Oxygen look like the examples below:</p> <p>|||</p> <p>Parent topic:Simplifying DITA</p>"},{"location":"create_topicframework/","title":"Creating the <code>simple_dita</code> framework","text":"<p>Having told Oxygen where to find the frameworks and their associated files, you can proceed to create the first framework. Because this is a simplified version of DITA 1.3, I've called my first framework <code>simple_dita</code>.</p> <p>For more information on creating custom frameworks in Oxygen, see OxygenXML Help: Create Custom Frameworks.</p> <ol> <li> <p>If the Preferences dialog isn't already open, go to Options&gt;Preferences&gt;Document Type Association.</p> </li> <li> <p>Click DITA and then Extend.</p> </li> <li> <p>In the Document type dialog that opens:</p> <ol> <li> <p>Give the new framework a Name. I used SIMPLE DITA.</p> </li> <li> <p>Set Priority to Highest.</p> </li> <li> <p>Set Storage to External, and click the folder icon to navigate to the <code>simple_dita</code> folder within your <code>customer_frameworks</code> folder.</p> </li> <li> <p>On the Classpath tab, select the <code>${baseFramework}/resources</code> row and click the wrench icon.</p> <p>Change the content in the Directory field to <code>${frameworkDir}/resources/</code> and click OK. In this case, the <code>${frameworkDir}</code> variable contains the path to the <code>custom_frameworks/simple_dita</code> folder.</p> </li> <li> <p>On the Templates tab, select all the rows and click the X icon to delete them all. Click the + icon, and enter <code>${frameworkDir}/templates/</code> in the Directory field and click OK.</p> </li> <li> <p>On the Author tab, edit the Menu, Contextual Menu, Toolbar, and Content Completion sub-tabs, to add or remove any icons not relevant to your framework.</p> </li> <li> <p>Click OK, and then OK again close the Preferences dialog.</p> </li> </ol> </li> </ol> <p>Once completed, your Elements and Attributes windows in Oxygen look like the examples below:</p> <p>|  |  |</p>"},{"location":"extended-markdown/","title":"New functionality for Markdown","text":"<p>MDITA extends what Markdown can do. As you have already seen, you can add videos to your Markdown content in MDITA topic syntax, but the real power of MDITA lies in the DITA content reuse features that it brings to Markdown content.</p> <ul> <li> <p>Text variables using key definitions to create variable text that allows you to update keywords in your document in one place and have the changes reflected throughout the document immediately. For more detail on this, see Using keys.</p> </li> <li> <p>Key references that allow you to assign a new name to a file or external resource that you can use when referencing that resource. You can happily change the file name, location, or URL in a ditamap without breaking any links in the document. For more detail on this, see Using keys.</p> </li> <li> <p>Content references that you can use to reference content in many places in the document without having many copies of the content. If the content ever needs updated, you can do it in one place and the changes automatically reflected everywhere else in the document. For more detail on this, see Using content references with MDITA.</p> </li> <li> <p>Text filtering that you can deploy to exclude elements of text from a build to produce different versions of a document for different purposes (perhaps different audiences, releases, software platforms etc.).For more detail on this, see Using filters with MDITA.</p> </li> </ul>"},{"location":"framework_location/","title":"Configuring the custom framework location","text":"<p>Having set up a location for the custom frameworks, the next step is to tell Oxygen where to find it:</p> <ol> <li> <p>In the Oxygen UI, go to Options&gt;Preferences&gt;Document Type Association&gt;Locations, and click Add.</p> </li> <li> <p>In the Choose frameworks directory dialog that appears, navigate to the <code>custom_ frameworks</code> folder, and click OK.</p> <p>The path to your <code>custom_ frameworks</code> folder appears in the Additional frameworks directories list.</p> </li> <li> <p>Click OK to save.</p> </li> </ol> <p>Note: If you plan to continue on to the next part, you can skip the final step here and continue working the Preferences dialog.</p> <p>Parent topic:Simplifying DITA</p>"},{"location":"framework_setup/","title":"Setting up a custom framework","text":"<p>Custom frameworks are a way to customize the Oxygen XML editor to work more easily with different XML vocabularies. We are not creating a new vocabulary here but rather restricting existing ones. We will need to create to custom frameworks: one for DITA topics, and one for DITA maps. These custom frameworks can then be shared with colleagues and imported into their Oxygen instances.</p> <p>The first step in defining the new frameworks is to set up the location from which they will be shared. I created a GitHub repository call <code>tools</code> and added the following directory structure:</p> <pre><code>custom_frameworks\n            - simple_dita\n                - resources\n                - templates\n            - simple_ditamap\n                - resources\n                - templates\n</code></pre> <ul> <li> <p>custom_frameworks - this folder is the root folder for all custom frameworks.</p> </li> <li> <p>simple_dita - is the container for the <code>simple_dita.framework</code> file.</p> </li> <li> <p>simple_ditamap - is the container for the <code>simple_ditamap.framework</code> file.</p> </li> <li> <p>/resources - holds the <code>cc_config.xml</code> file. There are many other files that could live here such as CSS or Schematron files if required.</p> </li> <li> <p>/templates - contains the topic or map templates.</p> </li> </ul> <p>When complete, colleagues can clone this repository, and use some Oxygen preferences settings to access its files.</p>"},{"location":"framework_setup/#template-and-resource-files","title":"Template and resource files","text":"<p>Now that you have the folder structure in place, it's time to add the template and resource files:</p> <ol> <li> <p>First move a copy of the <code>cc_config.xml</code> file you created in to the resources folder in within both the <code>simple_dita</code> and <code>simple_ditamap</code> folders.</p> <p>Note: In the example I cited in Creating a cc_config.xml file, both topic and map elements and attributes were configured. You could also create separate <code>cc_config.xml</code> files defining only the relevant elements and attributes for each framework.</p> </li> <li> <p>Next, copy the <code>Topic.dita</code> and <code>Topic.properties</code> files from <code>frameworks/dita/templates/topic</code> folder within your Oxygen install folder to the <code>simple_dita/templates</code> folder.</p> </li> <li> <p>Finally, copy the <code>Map.ditamap</code> and <code>Map.properties</code> files from <code>frameworks/dita/templates/map</code> folder within your Oxygen install folder to the <code>simple_ditamap/templates</code> folder.</p> </li> </ol> <p>Parent topic:Simplifying DITA</p>"},{"location":"frontmatter/","title":"MDITA frontmatter","text":"<p>Frontmatter refers to the content in YAML format that you can place at the start of an MDITA file. This content is essentially metadata that's useful when converting to other formats. This content, for example, is passed to the META tags in the HEAD of an HTML file. The content is also useful is the markdown file is ever converted to standard DITA XML.</p> <p>Markdown delineates frontmatter with 3 dashes above and below and must be the first thing in the topic. There can be no spaces or empty lines before the frontmatter. For example:</p> <pre><code>---\nauthor: Michael\n---\n\n# MDITA frontmatter\n\nFrontmatter refer to the contttnt in YAML format that can be placed at the start of an MDITA file.\nThis content is essentially metadata that is useful when converting to other formats. This content, for example, is passed to the META tags in the HEAD of an HTML file. The content is also useful is the markdown fie is ever converted to standard DITA XML.\n\n...\n</code></pre> <p>Two items of frontmatter are required: an id which serves as a unique identifier for the MDITA file, and the author so that the writer of the topic can be identified in the future. You can also use the value of the id as a key for the topic when you add it to the ditamap.</p> <p>Other possible frontmatter items include:</p> <ul> <li> <p>publisher</p> </li> <li> <p>source</p> </li> <li> <p>permissions</p> </li> <li> <p>audience</p> </li> <li> <p>category</p> </li> <li> <p>keywords</p> </li> <li> <p>resourceid</p> </li> </ul> <p>Parent topic:Writing and Reviewing MDITA</p>"},{"location":"get_out/","title":"Getting out of MDITA","text":"<p>All source format content is always in a state of transition. Whatever format your source files are in, you need be sure you can get them into a different source format, if you need to.</p> <p>MDITA may be the new flavour of the month, but like all tech writing technologies it's going to be old hat some day. Something newer and shinier may come along that answers your needs even better. Or simply, events (such as a corporate takeover) may require you to migrate your MDITA content to another format to fit in with your new parent company's documentation system.</p> <p>So how do you get out of MDITA?</p> <ol> <li> <p>The first step would be to transform it in a way that merges in all your referenced and filtered content to an intermediate format like HTML or a standard Markdown. Converting to Markdown, owing to its simplicity, gives you lots of options for conversion.</p> </li> <li> <p>Once you have the content in Markdown, you have several options:</p> <ol> <li> <p>Use a tool like Oxygen XML Editor's Batch Convertor tool to switch from Markdown to DITA/Docbook/XHTML. The Batch Convertor tool in Oxygen is probably the cleanest way to get Markdown into DITA proper and provides excellent results.</p> </li> <li> <p>Use Pandoc the universal converter which convert Markdown to a range of formats (including other docs-as-code formats like asciidoc).</p> </li> <li> <p>If you want to convert to DITA and don't use Oxygen XML Editor, you can use the DITA-OT's Normalized DITA transform. This works pretty well but requires a bit more clean-up than the Batch Convertor tool. The converted files still have a .md extension which you have to change to .dita, for example, and the transform adds some unnecessary attributes and other stuff which you need to remove.</p> </li> </ol> </li> </ol> <p>Parent topic:Working with MDITA</p>"},{"location":"intro/","title":"Hello","text":"<p>I am Michael McLoughlin, a professional technical writer based in Belfast, N. Ireland.</p> <p>If you are looking at this site, it's because I have sent it as an example of some of technical writing - probably as part of a job application. </p> <p>It's difficult for technical writers to showcase their skills since, more often than not, they don't own the copyright to their work. To remedy this, I have provided some pieces I have written on a variety of technical writing topics.</p> <p>Most of the content here covers esoteric DITA and DocOps subjects that I have researched to solve real world documentation problems that I have encountered.</p> <p>Feel free to look around.</p>"},{"location":"intro/#about-this-site","title":"About this site","text":"<p>This is just some information for the curious on the tools used to construct this site.</p> <p>The content of this site is written in Markdown and published as HTML using the MkDocs static site generator.</p> <p>The site builds using GitHub Actions and it also employs a custom Vale Markdown linter.</p>"},{"location":"limitations/","title":"Limitations","text":"<p>As theme files are a relatively recent innovation from the team behind the DITA-OT, there are limitations to what you can do with them. With new releases of the toolkit, there may well be further functionality added but theme files are likely not replace all the functionality you can achieve by building a custom PDF plugin. There are several reasons for this:</p> <ul> <li> <p>Theme files only interact with the XSL attributes files in the PDF2 plugin. They don't change anything in the XSLT templates. This means you can't do advanced configuration of PDFs (for example adding bookmap variables to a cover page).</p> </li> <li> <p>There are also not insignificant financial reasons for not developing theme files beyond a certain point. Many supporters of the DITA-OT are DITA consultants who make a living out of writing custom PDF and other DITA-OT plugins, and they would not be happy if there was tool that allowed customers to do it for themselves.</p> <p>Similarly, some of the DITA-OT's sponsors are software houses that sell tools for producing PDF output from DITA (such as Syncrosoft's Oxygen Styles Basket, or Antenna House's PDF5-ML plugin). Any open source tool that seriously rivalled their proprietary offerings could ultimately affect the DITA-OT project's funding. Of course that doesn't mean that an independent developer couldn't develop such an open source tool based on theme files.</p> </li> </ul>"},{"location":"limitations/#so-what-cant-you-do-with-theme-files","title":"So what can't you do with theme files?","text":"<p>Having created several PDF templates now using theme files, here are some limitations that I found:</p> <ul> <li> <p>Front covers - Other than <code>&lt;title&gt;</code>, <code>&lt;booktitle&gt;</code> and <code>&lt;booktitlealt&gt;</code> (if you are using a bookmap) there are no other variables you put on the front page. I also was not able to find a way to style the <code>&lt;booktitlealt&gt;</code> to show subtitle content - which means I had to omit it.</p> </li> <li> <p>Back covers - There is no way to add a back cover to your PDF document.</p> </li> <li> <p>Footers - Configuration of footer content has limitations. You can add page numbers and even some text, but all footer content must be styled the same way. So if your page number is right-aligned and bold, so is any text be that you put in there. Basically, footers in theme files are good for page numbers, and anything else, like copyright text, would be better placed elsewhere in your document.</p> </li> <li> <p>Tables - I could find no way to style table cell borders or content.</p> </li> <li> <p>Heading levels - You can only style headings as far as H4. The output styles the H5 and H6 headings but there is no way change this. Although you can style <code>&lt;example&gt;</code> and <code>&lt;section&gt;</code> titles.</p> </li> <li> <p>Lists - You can't stlye list item markers (numbers or bullets).</p> <p>Embedded lists (lists within lists) aren't styled differently from their parent. An embedded numbered list is styled 1, 2, 3, etc. rather than a, b, c, or i, ii, iii for example. Embedded unordered lists use the same bullet style as their parent list.</p> </li> </ul> <p>Despite the above reservations, the theme file feature is in active development, and the DITA-OT developer Jarno Elovirta has said that he would continue to add new features in upcoming releases. Hopefully, the issues outlined above are addressed in release 4.1.</p>"},{"location":"linter/","title":"Linting Markdown with Vale","text":""},{"location":"linter/#install-vale","title":"Install Vale","text":"MacLinuxWindows <pre><code># If you have Homebrew installed:\n\nbrew install vale\n</code></pre> <pre><code># If you use apt-get:\n\nsudo apt-get install vale\n</code></pre> <pre><code># If you have Chocolatey installed:\n\nchoco install vale\n</code></pre>"},{"location":"linter/#clone-this-repository","title":"Clone this repository","text":"<pre><code>git clone git@github.com:ditatechwriter/dtw-vale.git\n</code></pre>"},{"location":"linter/#configure-vale","title":"Configure Vale","text":"<ol> <li> <p>Add the <code>.vale.ini</code> file to the root of the folder of the repository whose content you want to lint.</p> </li> <li> <p>Add the <code>styles</code> folder to the <code>.github</code> folder of the repository.</p> </li> <li> <p>Update <code>.gitignore</code>:</p> <pre><code># Vale\n.github/styles  # required if the repo uses GitHub Actions\n.vale.ini       # optional\n</code></pre> </li> </ol>"},{"location":"linter/#install-visual-studio-code-vale-extension","title":"Install Visual Studio Code Vale extension","text":"<ol> <li> <p>Install the Vale VS Code extension.</p> </li> <li> <p>Update the Vale VS Code extension settings to point to the Vale executable.</p> </li> </ol>"},{"location":"mdita/","title":"Working with MDITA","text":"<p>With the advent of the upcoming Lightweight DITA (LwDITA) standard, the advantages of the docs-as-code approach are available in DITA. LwDITA is a simplified form of the DITA standard with only 48 tags in total and comes in 3 flavors:</p> <ul> <li> <p>XDITA - a subset of the main DITA standard XML elements.</p> </li> <li> <p>HDITA - A DITA variant written in HTML5 rather than XML.</p> </li> <li> <p>MDITA - A DITA variant written in Markdown rather than XML. MDITA is the same as GitHub-flavored Markdown but also incorporates MultiMarkdown features for tables.</p> </li> </ul> <p>MDITA is the real game changer for a docs-as-code approach for DITA but you need all 3 variants for a complete solution.</p> <p>As with standard Markdown, you can include HTML tags, and in this case you can use HDITA tags in MDITA files. The use of HDITA tags allows important DITA features such as content referencing and content filtering. Use of HDITA tags doesn't add enough complexity to the MDITA source that they interfere with ease of editing for non-DITA savvy reviewer.</p> <p>As with full-fat DITA, you organize MDITA files into maps. Although MDITA you can write maps in Markdown, there is little or no tool support for this yet. Therefore use maps written in standard DITA or XDITA. Maps are the organizing principle - the navigation table of contents - for a documentation site.</p> <p>You can also add specialized HDITA files holding key definitions or content reference content used in build for processing only to maps along with the MDITA files.</p>"},{"location":"mdita_syntax/","title":"MDITA topic syntax","text":"<p>The DITA Open Toolkit website provides a cheat-sheet for MDITA mark-up: MDITA syntax reference. What follows is a brief r\u00e9sum\u00e9 of the most commonly used syntax items.</p> <p>MDITA uses on CommonMark as a basis.</p>"},{"location":"mdita_syntax/#headings","title":"Headings","text":"<p>As DITA assigns heading level by position in the map, it's not a good idea to have more than one level one heading in an MDITA topic. If you want to have sections in your MDITA topic, assign a level 2 heading and add the .section class value in curly brackets as in the following example:</p> <pre><code># Topic title\n\n## Section title {.section}\n</code></pre> <p>Don't include any level three or lower headings in a MDITA topic. You can only 1 level 1 heading in a topic but you can have as many level 2 sections as you like, although you must not have sections within sections.</p> <p>If you a complex multi-level heading topic, break it up into smaller topics and assign the required heading levels in the map.</p>"},{"location":"mdita_syntax/#paragraphs","title":"Paragraphs","text":"<p>Paragraphs are separated by 2 returns as in most flavors of Markdown.</p> <p>The first paragraph in an MDITA file is (in traditional DITA terms) a shortdesc element by transform plugins.</p>"},{"location":"mdita_syntax/#links","title":"Links","text":"<p>Links use the following format:</p> <pre><code>[Markdown](test.md)\n[DITA](test.dita)\n[HTML](test.html)\n[External](http://www.example.com/test.html)\n</code></pre> <p>However, if you are referring to a Markdown file in the same document, and that file has a key defined for it in the ditamap, you can just reference the key within square brackets. For example:</p> <pre><code>For more information, see [using-maps].\n</code></pre> <p>When you build the document, the build process replaces key by the title of the topic. The same applies for keys defined in an external links map. For more information, see Using keys.</p>"},{"location":"mdita_syntax/#images","title":"Images","text":"<p>Images can be inline or on their own line and can use titles and alt content.</p> <pre><code>An inline ![Alt](test.jpg).\n\n![Alt](test.jpg)\n\n![Alt](test.jpg \"Title\")\n</code></pre>"},{"location":"mdita_syntax/#inline-elements","title":"Inline elements","text":"<p>The following inline elements are possible:</p> <pre><code>**bold** or __bold__\n*italic* or _italic_\n</code></pre> <p>Note</p> <p>Strikethough (as in GitHub-flavoured Markdown) is not permitted. Underline, codephrase, subscript, and superscript can added by using the relevant HDITA tags with a HDITA snippet:</p> <pre><code>&lt;p&gt;This is an &lt;u&gt;underline&lt;/u&gt;.&lt;/p&gt;\n&lt;p&gt;This is an &lt;sub&gt;subscript&lt;/sub&gt;.&lt;/p&gt;\n&lt;p&gt;This is an &lt;sup&gt;superscript&lt;/sup&gt;.&lt;/p&gt;\n</code></pre>"},{"location":"mdita_syntax/#alerts","title":"Alerts","text":"<p>There is no specific MDITA markup for Notes/Alerts/Callouts. Use the HDITA &lt;note&gt; tag wrapped in a &lt;p&gt; tag. Use the type attribute to define different types of note. See the options below:</p> <pre><code>&lt;p&gt;&lt;note&gt;This is a note&lt;/note&gt;&lt;/p&gt;\n&lt;p&gt;&lt;note type=\"caution\"&gt;This is a caution &lt;/note&gt;&lt;/p&gt;\n&lt;p&gt;&lt;note type=\"danger\"&gt;This is a danger&lt;/note&gt;&lt;/p&gt;\n&lt;p&gt;&lt;note type=\"notice\"&gt;This is a notice&lt;/note&gt;&lt;/p&gt;\n&lt;p&gt;&lt;note type=\"trouble\"&gt;This is a trouble&lt;/note&gt;&lt;/p&gt;\n&lt;p&gt;&lt;note type=\"warning\"&gt;This is a warning&lt;/note&gt;&lt;/p&gt;\n</code></pre>"},{"location":"mdita_syntax/#lists","title":"Lists","text":"<p>Multi-level ordered and unordered lists are possible.</p> <p>Unordered lists:</p> <pre><code>- Item 1\n- Item 2\n- Item 3\n\n* Item 1\n* Item 2\n* Item 3\n\n* Item 1\n    * 2nd Item 1\n* Item 2\n* Item 3\n    - 2nd level item 1 - 2nd level item 2      * Item 4\n</code></pre> <ul> <li> <p>Item 1</p> </li> <li> <p>Item 2</p> </li> <li> <p>Item 3</p> </li> </ul> <p>Example with asterisks:</p> <ul> <li> <p>Item 1</p> </li> <li> <p>Item 2</p> </li> <li> <p>Item 3</p> </li> </ul> <p>Example with 2nd level lists items:</p> <ul> <li> <p>Item 1</p> <ul> <li>2nd Item 1</li> </ul> </li> <li> <p>Item 2</p> </li> <li> <p>Item 3</p> <ul> <li> <p>2nd level item 1</p> </li> <li> <p>2nd level item 2</p> </li> </ul> </li> <li> <p>Item 4</p> </li> </ul> <p>Ordered lists:</p> <pre><code>1. Item 1\n1. Item 2\n1. Item 3\n    1. 2nd level item 1\n    1. 2nd level item 2\n    1. 2nd level item 3\n1. Item 4\n</code></pre> <ol> <li> <p>Item 1</p> </li> <li> <p>Item 2</p> </li> <li> <p>Item 3</p> <ol> <li> <p>2nd level item 1</p> </li> <li> <p>2nd level item 2</p> </li> <li> <p>2nd level item 3</p> </li> </ol> </li> <li> <p>Item 4</p> </li> </ol>"},{"location":"mdita_syntax/#tables","title":"Tables","text":"<p>MDITA also incorporates MultiMarkdown or GitHub-flavoured Markdown style tables:</p> <pre><code>| First Header | Second Header | Third Header |\n| ------------ | :-----------: | -----------: |\n| Content      | *Long Cell*                 ||\n| Content      | **Cell**      | Cell         |\n</code></pre> First Header Second Header Third Header Content Long Cell Content Cell Cell <p>Admittedly MDITA, like any flavor of Markdown, is weak when it comes to tables. Markdown tables must be short and simple or they become virtually impossible to read. Reviewing Markdown content that content long and/or complex tables is difficult and defeats the purpose.</p> <p>Warning</p> <p>If you have a documentation that has many tables then Markdown-based systems are probably less useful. A more robust system like standard DITA is more appropriate in that case.</p>"},{"location":"mdita_syntax/#video","title":"Video","text":"<p>You can't add videos to a Markdown file but by adding the HDITA HTML5 tags to the file you can access video:</p> <pre><code>Check out the video below for more information:\n\n&lt;video title=\"My New Video\" controls autoplay loop muted&gt;\n&lt;source src=\"media/vid1.mp4\" poster=\"vid1.jpg\"/&gt;\n&lt;/video&gt;    </code></pre> <p>You need to use an image as poster in place of the video for the user to access it.</p>"},{"location":"mdita_syntax/#escaping-special-characters","title":"Escaping special characters","text":"<p>Escape special characters using a backslash.</p>"},{"location":"multi-deliverables/","title":"Building multiple deliverables in GitHub","text":"<p>The beauty of using Project files in your GitHub builds is that a lot of the build information is already contained in the project file itself. You can use one <code>dita</code> command to build not just multiple documents from different ditamaps but also different output types for the same document, provided that:</p> <ol> <li> <p>Your GitHub workflow file downloads all the required plugins for the output types you want to build.</p> </li> <li> <p>Your project file includes all the transtype information you need to define the output formats.</p> </li> </ol> <p>The following project file defines three deliverables for the Grunt Master 3000 Guide: a HTML5 website, a PDF version built with a custom PDF plugin, and another PDF version that uses the basic PDF2 plugin and which requires a theme file (for more information, see PDF2 theme files). Because of conflicting ditaval filter files, there are 2 different contexts for the Grunt Master 3000 Guide - one for each output format.</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"https://www.dita-ot.org/project\"&gt;\n\n&lt;--! Grunt Master 3000 Guide HTML 5 deliverable --&gt;\n\n  &lt;context name=\"Grunt Master 3000 Guide\" id=\"html5_ug_gruntmaster3000\"&gt;\n    &lt;input href=\"ug_gruntmaster3000.ditamap\"/&gt;\n    &lt;profile&gt;\n      &lt;ditaval href=\"exclude_pdfonly.ditaval\"/&gt;\n    &lt;/profile&gt;\n  &lt;/context&gt;\n\n  &lt;deliverable name=\"Grunt Master 3000 Guide\" id=\"ug_gruntmaster3000_html5\"&gt;\n    &lt;context idref=\"html5_ug_gruntmaster3000\"/&gt;\n    &lt;output href=\"./html5-output\"/&gt;\n    &lt;publication transtype=\"html5\"&gt;\n      &lt;param name=\"args.css\" href=\"../css/custom.css\"/&gt;\n      &lt;param name=\"args.copycss\" value=\"yes\"/&gt;\n    &lt;/publication&gt;\n  &lt;/deliverable&gt;\n\n&lt;--! Grunt Master 3000 Guide PDF deliverables --&gt;\n\n  &lt;context name=\"Grunt Master 3000 Guide\" id=\"pdf_ug_gruntmaster3000\"&gt;\n    &lt;input href=\"ug_gruntmaster3000.ditamap\"/&gt;\n    &lt;profile&gt;\n      &lt;ditaval href=\"exclude_html5only.ditaval\"/&gt;\n    &lt;/profile&gt;\n  &lt;/context&gt;\n\n &lt;deliverable name=\"Grunt Master 3000 Guide\" id=\"ug_gruntmaster3000_custpdf\"&gt;\n    &lt;context idref=\"pdf_ug_gruntmaster3000\"/&gt;\n    &lt;output href=\"./pdf-output\"/&gt;\n    &lt;publication transtype=\"custom_pdf\"&gt;\n      &lt;param name=\"args.chapter.layout\" href=\"BASIC\"/&gt;\n      &lt;param name=\"outputFile.base\" value=\"Grunt Master 3000 Guide\"/&gt;\n    &lt;/publication&gt;\n  &lt;/deliverable&gt;\n\n &lt;deliverable name=\"Grunt Master 3000 Guide\" id=\"ug_gruntmaster3000_pdf\"&gt;\n    &lt;context idref=\"pdf_ug_gruntmaster3000\"/&gt;\n    &lt;output href=\"./pdf-output\"/&gt;\n    &lt;publication transtype=\"pdf2\"&gt;\n      &lt;param name=\"args.chapter.layout\" href=\"BASIC\"/&gt;\n      &lt;param name=\"outputFile.base\" value=\"Grunt Master 3000 Guide\"/&gt;\n    &lt;/publication&gt;\n  &lt;/deliverable&gt;\n\n&lt;/project&gt;\n</code></pre> <p>The GitHub Actions workflow file build section required to produce all three versions looks something like this:</p> <pre><code>...\njobs:\nbuild-dita:\nname: Build DITA\nruns-on: ubuntu-latest\nsteps:\n- name: Git checkout\nuses: actions/checkout@v2\n- name: Build HTML5\nid: DITA-build\nuses: dita-ot/dita-build-action@master\nwith:\ninstall: |\ndita install fox.jason.extend.css\ndita install net.infotexture.dita-bootstrap\ndita install fox.jason.prismjs\ndita install https://github.com/myCompany/DITA-plugins/archive/custom_pdf.zip\nbuild:  |\ndita --project=gm_3000.xml  --theme=mytheme.xml\n...\n</code></pre> <p>Note</p> <p>The  HTML5 build uses the first 3 plugins. The last for the custom PDF build. There is no need to install the PDF2 plugin as it's bundled with each DITA Open Toolkit release. The theme file is required for the PDF2 build. If not included, the output will revert to the default PDF2 styles. The theme file parameter is ignored by the other deliverable builds.</p>"},{"location":"other-project-functionality/","title":"Other things you can do with project files","text":"<p>There are a couple of other things you can do with project files. You can publish deliverables from several different project files at once, or just one deliverable from a project file containing several. You can also use the DITA <code>deliverables</code> command as a way to see what deliverables a project file contains.</p>"},{"location":"other-project-functionality/#using-multiple-project-files-together","title":"Using multiple project files together","text":"<p>The project file syntax also incorporates an &lt;include&gt; element which you can use to chain several project files together and produce all their deliverables in one go. See the following example, <code>all_deliverables.xml</code>:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;?xml-model href=\"https://www.dita-ot.org/rng/project.rnc\" type=\"application/relax-ng-compact-syntax\"?&gt;\n\n    &lt;project xmlns=\"https://www.dita-ot.org/project\"&gt;\n\n        &lt;include href=\"product1_deilverables.xml\"/&gt;\n        &lt;include href=\"product2_deilverables.xml\"/&gt;\n        &lt;include href=\"product3_deilverables.xml\"/&gt;\n\n    &lt;/project&gt;        \n</code></pre> <p>The command below therefore would build all the deliverables contained in the <code>product1_deilverables.xml</code>, <code>product2_deilverables.xml</code>, and <code>product3_deilverables.xml</code> project files:</p> <pre><code>dita --project=all_deliverables.xml\n</code></pre>"},{"location":"other-project-functionality/#listing-all-the-deliverables-in-a-project-file","title":"Listing all the deliverables in a project file","text":"<p>If a project file contains many deliverables, and especially if it's written in XML, it can be no easy task to find exactly which deliverables it builds. Luckily, there is a command for just for that. For example:</p> <pre><code>dita deliverables gm_deliverables.xml\n</code></pre> <p>The DITA <code>deliverables</code> command if used on the <code>gm_deliverables.xml</code> described in Building multiple documents returns each deliverable's ID and name:</p> <pre><code>ug_gruntmaster6000_html5 Grunt Master 6000 Guide\nug_gruntmaster3000_html5 Grunt Master 3000 Guide\nug_gruntmaster3000_pdf   Grunt Master 3000 Guide\n</code></pre>"},{"location":"other-project-functionality/#building-a-single-deliverable-from-a-project-file","title":"Building a single deliverable from a project file","text":"<p>If you only want to build a single deliverable and you know that its build parameters exist in a certain project file you can pass the deliverable's unique ID to the <code>--deliverable</code> switch with the DITA build command. The following example builds the PDF version of the Grunt Master 3000 Guide listed in the <code>gm_deliverables.xml</code> project file:</p> <pre><code>dita --project=gm_deliverables.xml --deliverable=ug_gruntmaster3000_pdf\n</code></pre> <p>Note</p> <p>You can also build all (or just one) of the deliverables in a project file you have open in Oxygen by going to Document&gt;Transformation&gt;Configure Transformation Scenario(s) and selecting either Publish DITA-OT Project (all deliverables) or Publish DITA-OT Project (select deliverable).</p>"},{"location":"pagefind-search-library/","title":"Pagefind Search Library","text":"<p>Pagefind is a JavaScript static search library than be easily integrated into the DITA-Bootstrap plugin. As it's written in Javascript, it runs the searches in the browser, and consequently is very fast.</p> <p>To install Pagefind you will need to have <code>npm</code> installed first. For instructions on how to install that, see https://docs.npmjs.com/downloading-and-installing-node-js-and-npm.</p> <p>After you have installed <code>npm</code> (if you don't have it already), getting search fully up-and-running on your site involves the following steps:</p> <ol> <li>From the command line, run an ordinary build of your document using the DITA-Bootstrap plugin.</li> <li> <p>Still in the command line, navigate to the output folder containing the HTML files and run the <code>pagefind</code> command:</p> <pre><code>npx pagefind --source .\n</code></pre> <p>This creates a <code>_pagefind</code> folder within the output folder that stores the search index for the document.</p> </li> <li> <p>Make a copy of the <code>[DITA-OT Install Folder]/libexec/plugins/net.infotexture.dita-bootstrap/xsl/html5-bootstrap.xsl</code>file (rename it <code>html5-bootstrap.orig</code> or similar). This is so you can restore the original file if need be.</p> </li> <li> <p>The Pagefind UI page provides a code snippet you can insert into the <code>html5-bootstrap.xsl</code> file (or other files like <code>includes/bs-navbar-default.hdr.xml</code>). Insert it immediately before the content <code>&lt;div&gt;</code> in the <code>html5-bootstrap.xsl</code> file to display the search bar beneath the site header menu.</p> <pre><code>...\n\n&lt;!--   Pagefind search snippet goes here   --&gt;\n&lt;div class=\"container-fluid  py-4\" id=\"search-wrapper\" style=\"background-color: #cfe2ff;\"&gt;\n&lt;link href=\"/_pagefind/pagefind-ui.css\" rel=\"stylesheet\"/&gt;\n&lt;script src=\"/_pagefind/pagefind-ui.js\" type=\"text/javascript\"&gt;&lt;/script&gt;\n&lt;div id=\"search\" class=\"container-lg\" style=\"max-width: 25%;\"&gt;&lt;/div&gt;\n&lt;script&gt;\nwindow.addEventListener('DOMContentLoaded', (event) =&gt; {\n        new PagefindUI({ element: \"#search\" });\n        });\n      &lt;/script&gt;\n&lt;/div&gt;\n&lt;!--   End of pagefind snippet   --&gt;\n&lt;div class=\"bs-container\" id=\"content\"&gt;\n...\n</code></pre> <p>In the example above, I have wrapped the Pagefind code snippet in a <code>&lt;div&gt;</code> and added some styling to the wrapper and the search <code>&lt;div&gt;</code>.</p> </li> <li> <p>Navigate to the folder that holds your document ditamap, and run another build.</p> </li> <li> <p>Move the output folder to a web server, and open a page to test the new search functionality.</p> <p>Tip</p> <p>If you have Python 3 installed, you can spin up a local web server in the document output folder using a command similar to the following:</p> <pre><code>python3 -m http.server 8000\n</code></pre> <p>Your content will be available at <code>http://localhost:8000/&lt;mypage.html&gt;</code>.</p> </li> </ol>"},{"location":"pdf2_themes/","title":"PDF2 theme files","text":"<p>For many years, DITA Information Architects have done battle with the mighty DITA Open Toolkit (DITA-OT) PDF2 plugin. Armed with Leigh White's indispensable tome DITA for Print, they have struggled to create custom PDF plugins that produce good looking PDFs from DITA source files. And while for truly bespoke PDF output, customizing the PDF2 plugin is the only way, release 4.0\u00a0of the DITA-OT offers an somewhat easier (but by no means simple) way to work with the PDF2 plugin - theme files.</p> <p>Prior to this, creating a custom PDF plugin involved creating a whole set of customization folders and override files (the system has many similarities with the methods used in the Docbook Style Sheets). It involved hacking around in XSLT templates and attributes files. Generally consultants did this work, usually when the team first converted to DITA. And often the expertise was never passed on, or soon lost as team personnel changed. Something as simple as a logo change or an update to brand colors could prove an expensive nightmare for teams that didn't have XSLT expertise on staff.</p> <p>Theme files are YAML files whose key/value pairs represent CSS properties and values (or actually XSL-FO properties which are often the same). Once configured, the theme file you can apply to the build instruction. For example:</p> <pre><code>dita -i some.ditamap -o out --format=pdf2 --theme=mytheme.yaml\n</code></pre> <p>The theme YAML file feeds the theme file parameters to the build-in PDF2 plugin at build time with no requirement to actually go in and mess with the XSLT attributes files within the PDF2 plugin itself. And although it may not solve all the problems of PDF creation from DITA, it goes a long way to help documentation teams work with PDF output in a manageable and maintainable way.</p>"},{"location":"project-file-structure/","title":"DITA-OT project file structure","text":"<p>A DITA project file is an XML file containing build parameters for one or more documents that you can pass to the <code>dita</code> build command.</p> <p>The following is a sample project file in XML format:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"https://www.dita-ot.org/project\"&gt;\n&lt;deliverable name=\"Grunt Master 6000 Guide\" id=\"ug_gruntmaster6000_html5\"&gt; &lt;context name=\"Grunt Master 6000 Guide\" id=\"ug_gruntmaster6000\"&gt;\n&lt;input href=\"ug_gruntmaster6000.ditamap\"/&gt;\n&lt;profile&gt;\n&lt;ditaval href=\"GM6000.ditaval\"/&gt;\n&lt;/profile&gt;\n&lt;/context&gt;\n&lt;output href=\"out\"/&gt;\n&lt;publication transtype=\"html5\"&gt;\n&lt;param name=\"args.css\" href=\"../css/custom.css\"/&gt;\n&lt;param name=\"args.copycss\" value=\"yes\"/&gt;\n&lt;/publication&gt;\n&lt;/deliverable&gt;\n&lt;/project&gt;\n</code></pre> Element Description project The wrapper element for deliverables in the project file. It has only one attribute <code>xmlns</code> which defines the XML namespace for the elements in the file. deliverable The wrapper element for all the deliverable parameters. Its attributes define the deliverable name and a unique ID for the deliverable. context This element wraps the elements that hold the input information (the source ditamap) and filters that are used by the build. Note: You can use context elements independently of the deliverable elements and so can use their own name and unique ID attributes. input This element stores the relative path to the input ditamap you want to use for the build within a <code>href</code> attribute. profile\u00a0 The <code>&lt;profile&gt;</code> element wraps one or more <code>&lt;ditamap&gt;</code> elements. ditaval This element stores the relative path to the any filter file you want to use for the build within a <code>href</code> attribute. There can be many <code>&lt;ditaval&gt;</code> tags for each context. output This element stores the relative path to the output folder where you want to deposit the outputted content within a <code>href</code> attribute. publication The <code>&lt;publication&gt;</code> element wraps parameter elements which content the build parameters passed to the DITA-OT. Importantly, it also must contain a <code>transtype</code> attribute that tells the DITA-OT which output format to transform the content into. param This element stores the actual build parameters that the DITA-OT uses when creating the output. Builds differ according to the output you have defined in the <code>&lt;publication&gt;</code> element <code>transtype</code> attribute. For a full list of parameters by output format, see the DITA-OT website <p>Visit the DITA-OT website to see examples of project files in JSON and YAML formats, and for other information on using project files.</p>"},{"location":"sample_theme_file/","title":"Working with theme files","text":"<p>The <code>libexec/docsrc/samples/themes</code> folder within the 4.0 (and later) release of the DITA-OT contains several example theme files. The most useful of which is the dita-ot-docs-theme.yaml file. It's a long file which I won't reproduce here but click the link to go to DITA-OT docs GitHub repository to see it in full.</p> <p>The easiest way to work with theme files to copy and edit your own version of the <code>dita-ot-docs-theme.yaml</code>.</p>"},{"location":"sample_theme_file/#uses-for-theme-files","title":"Uses for theme files","text":"<p>Even though theme files aren't as powerful as custom plugins, there is still a wide range of things you can do with them:</p> <ul> <li> <p>Define page, size, orientation and margins.</p> </li> <li> <p>Define headers and footers.</p> </li> <li> <p>Create a cover page and add an image and title to it.</p> </li> <li> <p>Style a range of block level and inline elements.</p> </li> <li> <p>Create style variables that you can use elsewhere in the theme file.</p> </li> <li> <p>Extend existing theme files to produce variants (for example, versions of the document in A4 and US Letter formats).</p> </li> </ul> <p>The DITA-OT website contains a reasonably good quickstart guide which, coupled with the sample theme file, are enough to get you started. A knowledge of XSL-FO properties (or at least CSS) would really help but a little trial and error, and practice styling some basic PDF output is useful.</p> <p>The following videos from the 2022 DITA-OT Day conference explain about the feature's raison d'\u00eatre.</p>"},{"location":"share_frameworks/","title":"Sharing the frameworks and layout","text":"<p>If you have saved the layout and custom framework files to GitHub repository, or shared location on your network, installing them is very straightforward:</p> <ol> <li> <p>First, clone the repository (or open the network location), where the files have been saved.</p> </li> <li> <p>To install custom editor layout in Oxygen, click Window&gt;Load Layout&gt;Custom, locate and select the <code>.layout</code> file. Then, click Open.</p> <p>Your editor layout updates automatically.</p> </li> <li> <p>To install the frameworks, first set the location of the new framework files:</p> <ol> <li> <p>In the Oxygen UI, go to Options&gt;Preferences&gt;Document Type Association&gt;Locations, and click Add.</p> </li> <li> <p>In the Choose frameworks directory dialog that appears, navigate to the <code>custom_ frameworks</code> folder, and click OK.</p> <p>The path to your <code>custom_ frameworks</code> folder appears in the Additional frameworks directories list.</p> </li> <li> <p>Click OK to save.</p> </li> </ol> </li> <li> <p>Next got to Options&gt;Preferences&gt;Document Type Association where you should the new frameworks installed. Deselect any other frameworks that reference DITA and click OK. The example below is from my machine:</p> <p></p> <p>The Elements and Attributes windows should reflect the restricted choices created in the <code>cc_config.xml</code> file. If they don't, close and reopen Oxygen.</p> </li> <li> <p>To check for the new templates, click File&gt;New. The Choose a file template dialog shows the new Topic and Map templates.</p> <p></p> </li> </ol>"},{"location":"share_frameworks/#how-do-i-undo-all-this","title":"How do I undo all this?","text":"<p>Undoing the changes imported above is very simple.</p> <ol> <li> <p>To return to the default Oxygen layout, click Window&gt;Load Layout&gt;Default.</p> </li> <li> <p>To return to the default DITA elements, attributes and templates, go to Options&gt;Preferences&gt;Document Type Association and deselect the new templates your you imported. Select all the other frameworks that mention DITA and click OK. You may need to restart Oxygen to changes. That's it!</p> </li> </ol> <p>Parent topic:Simplifying DITA</p>"},{"location":"simple-editor-layout/","title":"A simple editor layout","text":"<p>The final thing that I think can contribute to making the life of DITA newbie easier is a custom editor layout that only shows the Oxygen windows that a new user is most likely to use. In my experience, in addition to the main editor pane of course, these are:</p> <ul> <li> <p>DITA Maps manager</p> </li> <li> <p>Elements</p> </li> <li> <p>Attributes</p> </li> <li> <p>DITA Reusable Components</p> </li> </ul> <p>You may have your own preferences, but sharing your favorite editor layout couldn't be easier. Click Window&gt;Export Layout, give the layout a name and save it to a location such as GitHub repository from where you can share it as a <code>.layout</code> file.</p>"},{"location":"simplifying-dita/","title":"Simplifying DITA","text":"<p>One of the issues that teams that use DITA often have is finding writers with DITA skills. The base implementation of DITA has around 190 elements and many more attributes. The most popular DITA XML editor, Oxygen XML Author, is an powerful but not infrequently daunting tool for new users. The learning curve therefore can be steep for new writers, and the cost of hiring experienced DITA writers expensive.</p> <p>So, is it possible to simplify DITA and Oxygen to make them more user friendly for new writers?</p> <p>At the time of writing (Spring 2023), there is no news on when exactly the new Lightweight DITA 1.0 (LwDITA) standard is going to be released. From what I've seen it will be a great step forward in simplifying DITA and easing the steep learning curve encountered by many writers when taking on DITA for the first time.</p> <p>However, in the meantime, what do we do?</p> <p>Even though there is growing editor support for the new LwDITA DTDs and functionality, it's not quite there yet.</p> <p>And even when it comes online, LwDITA might be just too lightweight for your needs. I have worked with document sets that contained many complex tables and which were published to PDF. LwDITA only supports simple (as opposed to CALS) tables and doesn't support bookmaps at all. In a case like this, LwDITA would not be powerful enough.</p> <p>I think it's possible to simplify standard DITA 1.3 use for ordinary - especially new - writers, without having to write whole new DTDs.</p> <p>Here's how:</p> <ul> <li> <p>Stop worrying about Information Typing</p> <p>For many projects, the information type makes no difference in how you manage the content. You can forget about whether a topic is a task, a reference, or a concept. Just use the topic type for all topics. This is essentially the approach in LwDITA.</p> <p>This might have some DITA purists clutching their pearls over the very idea of using an ordered list for procedures instead of steps but, in the end, you can't tell in the output, and you may be saving someone from learning all those task elements.</p> </li> <li> <p>Stick to the <code>&lt;map&gt;</code> ditamap type wherever possible</p> <p>Again, this is the approach taken by the team creating LwDITA. Admittedly, jettisoning bookmaps may not be feasible if you need to publish PDF outputs.</p> </li> <li> <p>Radically reduce available elements you use</p> <p>Full-fat DITA 1.3 has something like 193 elements in its base implementation alone. The vast majority of which most writers don't use. I suggest auditing your content and looking at the type of elements and attributes you use and make a point of restricting access for writers to all the rest.</p> </li> <li> <p>Simplify the Oxygen XML Author UI</p> <p>Oxygen XML Editor/Author is my favorite software application. it's unbelievably powerful, well-designed, and no other editor comes even close when working with DITA. And it can be a bit daunting for first-time users. Luckily, it's UI is extensible, and there are many things you can do to hide a lot of the more complex functionality that most writers, especially relatively inexperience ones, simply don't use on a regular basis.</p> <p>Here are somethings you can do to make the Oxygen Editor more user friendly:</p> <ul> <li> <p>Edit the <code>cc_config.xml</code> file so that only the elements (and attributes) you actually use are available in the Elements and Attributes windows. Editing this file also hides the unwanted elements and attributes in the right-click content completion menus.</p> <p>You can also use the <code>cc_config.xml</code> file to enforce element patterns (for example always having a <code>&lt;p&gt;</code> element inside a <code>&lt;li&gt;</code> element).</p> </li> <li> <p>Create a shareable custom frameworks for topics and maps that novice OxygenXML users can install allow them work with the reduced list of elements and attributes.</p> </li> <li> <p>Define a simple editor layout with only the windows that are necessary, and share this with new team members. This is a big help for new users.</p> </li> </ul> </li> </ul>"},{"location":"using-mkdocs/","title":"Using MkDocs","text":"<p>MkDocs is Python-based static site generator that converts Markdown to HTML and was written with technical documentation site particularly in mind. It also plays quite nicely with the markdown content produced by the DITA Open Toolkit LwDITA plugin.</p> <p>MkDocs has many impressive built-in features (like lunr-based search) and a range of plugins and themes. The steps below explain how to install and configure MkDocs to publish DITA content.</p>"},{"location":"using-mkdocs/#publishing-dita-content-with-mkdocs","title":"Publishing DITA content with MkDocs","text":"<p>Getting good looking HTML-based output from DITA content isn't always easy. Oxygen's built-in Webhelp Responsive plugin is eminently configurable and produces some lovely looking output but comes with a $3000 US price tag (at time of writing) if you want to run it from the command line. Infotexture's open source DITA Bootstrap plugin is free but requires reasonable knowledge of Bootstrap 5 to configure it. It's also missing important features like a built-in search (which can be difficult to implement).</p> <p>If you haven't got the cash to do nightly builds of your content using Webhelp Responsive, or the time or energy to learn Bootstrap, MkDocs comes with a relatively shallow learning curve and you can use it to produce impressive looking documentation in a few minutes.</p>"},{"location":"using-mkdocs/#installing-python-mkdocs-and-its-dependencies","title":"Installing Python, MkDocs, and its dependencies","text":"<p>MkDocs is a Python package, so you will need to have both Python and its packet manager <code>pip</code> installed.</p> <ol> <li> <p>Check if you have Python3 already installed:</p> <pre><code>python3 --version\n</code></pre> <p>If you get command not found, you'll need to install it.</p> <p>Followthese instructions for installing Python for your operating system.</p> </li> <li> <p><code>pip</code> is usually installed automatically when you install Python, you can test that by issuing the following command:</p> <pre><code>pip3 --version\n</code></pre> <p>Again, if you get command not found, you'll need to install it. Followthese instructions for installing pip for your operating system.</p> </li> <li> <p>Once you have Python and pip up and running, you can proceed to install MkDocs:</p> <pre><code>pip3 install mkdocs\n</code></pre> <p>This command installs the basic MkDocs page with the default themes and features. Use the <code>mkdocs --version</code> command to check that it has installed properly.</p> <p>Tip: If the <code>mkdocs --version</code> does not work, use <code>python3 -m mkdocs --version</code>.</p> <p>The Material for MkDocs theme is easily configurable theme for MkDocs that has many plugins and extensions. To install it, use the following command:</p> <pre><code>pip3 install mkdocs-material\n</code></pre> <p>Finally, in order to make configuration of your new site's documentation navigation easier, install the mkdocs-literate-nav plugin for MkDocs:</p> <pre><code>pip3 install mkdocs-literate-nav\n</code></pre> </li> </ol>"},{"location":"using-mkdocs/#converting-dita-to-github-flavored-markdown","title":"Converting DITA to GitHub-flavored Markdown","text":"<p>MkDocs consumes Markdown files so before it can display your DITA content, you need to convert it to GitHub-flavored Markdown using the LwDITA plugin that comes with the DITA-OT 2.4 or later. See the information on the LwDITA plugin GitHub page for the build command to use with your version of the DITA-OT. For the most recent release, use:</p> <pre><code>dita -i my-map.ditamap -o docs --format=markdown_github\n</code></pre> <p>MkDocs automatically looks for content in the <code>docs</code> folder but you can call the output folder whatever you want and use the MkDocs configuration file to point to it. You can also add any further build parameters you need to the <code>dita</code> command (or use a project file).</p>"},{"location":"using-mkdocs/#configuring-mkdocs","title":"Configuring MkDocs","text":"<p>You can configure MkDocs mostly by using a single configuration file: <code>mkdocs.yml</code>. You must add this file to the folder that contains the <code>docs</code> folder.</p> <p>A basic <code>mkdocs.yml</code>:</p> <pre><code>site_name: My site name\ntheme:\nname: material\nplugins:\n- search\n- literate-nav:\nnav_file: index.md\n</code></pre> <ul> <li><code>site_name</code> - the name of the site that will appear in the site header</li> <li><code>theme</code> - the name of the MkDocs theme - in this case it is set to the Material for MkDocs theme installed earlier.</li> <li><code>plugins</code> - the lunr search plugin that indexes the site content, and the mkdocs-literate-nav plugin that uses the <code>index.md</code> file produced by the LwDITA transform to create the site navigation correctly.</li> </ul> <p>You will almost certainly want to configure more features in the <code>mkdocs.yml</code> file. It's worth your time to go through the Material for MkDocs site (as well as the Best of MkDocs GitHub repository) to see the range of configuration options available.</p>"},{"location":"using-mkdocs/#viewing-and-building-the-site","title":"Viewing and building the site","text":"<p>Once you have transformed your DITA content to Markdown, and configured the <code>mkdocs.yml</code> file, you are ready to test and build the site using MkDocs.</p> <ol> <li>Open a terminal at the folder containing your <code>mkdocs.yml</code> file, and issue the <code>mkdocs serve</code> command. This MkDocs built-in HTTP service that serves your content at <code>127.0.0.1:8000</code>. Open a browser at that address to your converted content in MkDocs.</li> <li>You can make changes to the <code>mkdocs.yml</code> file (and the Markdown content - although it's recommended you do that in DITA and rebuild) and the MkDocs server will display them immediately.</li> <li>When you are finished, use <code>Ctrl+c</code> to stop the MkDocs HTTP service, and then issue the <code>mkdocs build</code> command. This command builds the site to a <code>site</code> folder. The site folder and/or its contents you can then upload to a web server.</li> </ol>"},{"location":"using_maps/","title":"Organizing topics with maps","text":"<p>You organize a collection of MDITA topics using a ditamap. Ditamaps are XML files that function like a table of contents to decide the order and the heading level of a topic within a document. Ditamaps are XML files.</p> <p>Although the Lw-DITA specification includes ditamaps written in MDITA, it's more practical to use XDITA or standard DITA for the following reasons:</p> <ul> <li> <p>Ditamaps aren't something that you need reviewers to update so there is no need to keep them in Markdown.</p> </li> <li> <p>You can output ditamaps in Markdown format as an index.md file by the DITA Open Toolkit Markdown transform so there is no requirement to keep the map in Markdown.</p> </li> </ul> <p>As with standard DITA, you can have a root map that can contain content submaps as well as external links or key definition maps that have a processing-only role. As is also standard best practice, you can add warehouse topics to hold images and content that used in multiple locations and accessed using the context reference (or conref) mechanism.</p> <p>A sample ditamap:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE map PUBLIC \"-//OASIS//DTD DITA Map//EN\" \"map.dtd\"&gt;\n&lt;map id=\"intro-to-MDITA\"&gt;    &lt;title&gt;DITA-as-code&lt;title&gt;\n&lt;topicref format=\"markdown\" href=\"Dita-dac.md\" keys=\"ddac\"/&gt;\n&lt;topicref format=\"markdown\" href=\"DITA4dac.md\" keys=\"d4dac\"&gt;\n&lt;topicref format=\"markdown\" href=\"write-review-MDITA.md\" keys=\"write-MDITA\"/&gt;\n&lt;topicref format=\"markdown\" href=\"Ditamaps4dac.md\" keys=\"MDITA-maps\"/&gt;\n&lt;topicref format=\"markdown\" href=\"MDITA-keys.md\" keys=\"MDITA-keys\"/&gt;\n&lt;topicref format=\"markdown\" href=\"MDITA-conrefs.md\" keys=\"MDITA-conrefs\"/&gt;\n&lt;topicref format=\"markdown\" href=\"MDITA-filters.md\" keys=\"MDITA-filters\"/&gt;\n&lt;topicref format=\"markdown\" href=\"publish-MDITA.md\" keys=\"publish-MDITA\"/&gt;\n&lt;/topicref&gt;\n&lt;mapref href=\"externallinks.ditamap\" keys=\"extlinksmap\" processing-role=\"resource-only\"/&gt;\n&lt;mapref href=\"keydefs.ditamap\" keys=\"keydefsmap\" processing-role=\"resource-only\"/&gt;\n&lt;topicref format=\"markdown\" href=\"conrefs.md\" keys=\"conrefs\" processing-role=\"resource-only\"/&gt;\n&lt;topicref format=\"mardown\" href=\"images.md\" keys=\"images\" processing-role=\"resource-only\"/&gt;   &lt;/map&gt;\n</code></pre>"},{"location":"using_maps/#ditamap-tags","title":"Ditamap tags","text":"<p>The first tag provides information the version of XML used. The second tag references the Document Type Definition (DTD) for the map. This DTD defines what XML tags can appear in a map and in what order. These first 2 tags appears in all ditamaps of this type.</p> <p>The other tags, though are of interest to us:</p> <ul> <li> <p><code>map</code> - The <code>&lt;map&gt;</code> tag wraps all the other tags and always requires an id attribute as a unique identifier for the map.</p> </li> <li> <p><code>title</code> - The <code>&lt;title&gt;</code> tag gives the document as a whole its title.</p> </li> <li> <p><code>topicref</code> - You use <code>&lt;topicref&gt;</code> tags to reference topics. <code>&lt;topicref&gt;</code> tags can contain other <code>&lt;topicref&gt;</code> tags. You can use the following attributes with the <code>&lt;topicref&gt;</code> tag:</p> <ul> <li> <p>href - The href attribute stores the path to the MDITA topic.This attribute is mandatory.</p> </li> <li> <p>format - This attribute defines the format of the file referenced. For our purposes, this usually has a value of markdown. This attribute is mandatory.</p> </li> <li> <p>keys - The keys attribute stores a value that functions as an alternative name when referencing to the topic. For a more in-depth discussion of keys, see in Using keys. Using a key allows you to change the name or location of a topic (in the href attribute) without breaking any links or references to it elsewhere in the document.</p> </li> <li> <p>processing-role - The processing-role attribute is only used for certain special topics (and maps) that usually containing content that you want to reuse elsewhere in the document. For that reason you don't want that topic to appear as-is in the document. The processing-role attribute usually has a value of resource-only.</p> </li> </ul> </li> <li> <p><code>mapref</code> - You can also reference other maps within your map. Use the <code>&lt;mapref&gt;</code> tag to reference whole maps. It uses the same attributes as the <code>&lt;topicref&gt;</code> tag, but the format attribute isn't mandatory as the format is always ditamap.</p> </li> </ul> <p>There are quite a few other tags and attributes that you can use in a map (see Using keys for some more of those). The 4 tags listed above are the ones that you can use on a day-to-day basis when you work with maps.</p>"},{"location":"using_maps/#types-of-map","title":"Types of map","text":"<p>The basic type of map shown here is usually called a root map. You use it to define the structure of the document. However, there are other types of map. To make full use of MDITA's content reuse functionality, you can also use key definition maps and external link maps. These maps are usually sub-maps within the root maps and you use them to define variables and store external links, respectively. Again see Using keys for more information on key definition and external links maps.</p>"},{"location":"write-review-MDITA/","title":"Writing and Reviewing MDITA","text":"<p>MDITA is Markdown and so learning how to use it's much simpler than learning how to use full-blown DITA.</p> <p>Writers may need a little more training on how to incorporate DITA mechanism like keys, conrefs, and ditaval filters when writing in MDITA but a couple of hours is enough to train any new writer with no knowledge of Markdown or DITA how to write effective MDITA.</p> <p>Writers would still probably be better to use an XML editor especially to validate any XDITA or HDITA tags they use. Reviewers however should be able to use their favorite text editor to review and make updates, upload to their VCS and issue a pull request just as if they were editing source code.</p> <p>Normally, to get DITA content reviewed, writers had to transform it into another format such as PDF and circulate that to a reviewer for comments. Then, use those comments to manually update the DITA source files. Or, technical publication departments would have to invest in online XML editors like Oxygen Web Author or Xeditor, that provide a WYSIWYG front-end that hides the XML complexity from reviewers. With MDITA, DITA writers can enjoy the same review workflow as writers in Markdown.</p>"}]}